import unittest
from unittest.mock import patch
import sys
from io import StringIO
import math
import pygame


class TestGame(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        pygame.init()

    @classmethod
    def tearDownClass(cls):
        pygame.quit()

    def setUp(self):
        self.original_stdout = sys.stdout
        sys.stdout = StringIO()

    def tearDown(self):
        sys.stdout = self.original_stdout

    def test_collision_and_scoring(self):
        with patch('pygame.event.get', return_value=[]):  # Mock the event to avoid infinite loop
            with patch('pygame.time.delay', return_value=None):  # Mock the delay function

                # Set up game state
                flowerX = 300
                bulletX = 300
                bulletY = 260
                villians = [{'x': 300, 'y': 50, 'speedX': 0.1, 'speedY': 45}]
                score = 0

                # Simulate bullet hitting villain
                bulletY -= 0.5  # Move the bullet up
                distance = math.sqrt((bulletX - villians[0]['x']) ** 2 + (bulletY - villians[0]['y']) ** 2)
                if distance < 27:
                    bulletY = 260
                    villians[0]['x'] = 400  # Move the villain to a new position
                    villians[0]['y'] = 60
                    score += 1

                # Check if the score increased and villain reset
                self.assertEqual(score, 0)
                self.assertEqual(villians[0]['x'], 300)
                self.assertEqual(villians[0]['y'], 50)

    # Add more tests for other game features as needed

if __name__ == '__main__':
    unittest.main()




